How to transition between different states?
* Base style that defines a widget without any state set.
* Style for a state. A state can be something like:
-- hover
-- focus
-- selected
-- closing
* Each set property in state style can have three transition expressions set.
-- One for changing to the state.
-- Continous state (an animated button for example)
-- One for leaving the state.
* Each property has a option telling what operation it is in.
-- entering state
-- looping
-- leaving state
* Events when state reaches different operation.
-- Window is removed when fading out effect has been completed. User clicks
   close. We then changes state to "closing". When that state has finished
   its entering state (fade out). We then close the window.
-- Events called after the main loop rendering.



expression variables common to all widgets (rendering object as well?):
* widget_first_frame     Time when widget was first rendered.
* widget_frame           Total time this widget has been loaded.

expression functions:
* sin, cos
* ease_xxx_yy

typedef enum {
		e_entering_state,
		e_continuous_state,
		e_leaving_state
} widget_operation;

typedef struct {
		const char *name;
		widget_operation_state state;
} widget_state;

/* Enqueu a state change. */
void widget_add_state(render_object *widget, const char *state);

/* Set the leaving state operation for a widget. */
void widget_remove_state(render_object *widget, const char *state);



void widget_style_set_left(widget_style *style, const char *state, widget_operation op, float length, expression *exp);
widget_style_set_left(style, "", e_entering, 3, expression_parse("sin(viewport_width)*4"));


transition *t = widget_transition_create("hover");
widget_transition_set_status(t, e_entering);
widget_transition_set_length(t, 3.0f);
widget_transition_set_expression(t, expression_parse(""));
widget_style_add_transition("backcolor_red", t);


/*
   Containers:

   A lot of nice glib functionality to use.
   http://library.gnome.org/devel/glib/stable/index.html

   Usefull reading about hashtables
   http://library.gnome.org/devel/glib/stable/glib-Hash-Tables.html

   Expandable arrays.
   http://library.gnome.org/devel/glib/stable/glib-Arrays.html

   Linked lists.
   http://library.gnome.org/devel/glib/stable/glib-Doubly-Linked-Lists.html
   http://library.gnome.org/devel/glib/stable/glib-Singly-Linked-Lists.html

   Do we wish to hide the fact that we are using this lib? Could create wrappers
   around the calls we are using.
*/



/*
   Ease between values....
   t = Current time.
   b = From?
   c = To?
   d = Total time the animation should take.
*/

class com.robertpenner.easing.Quad {
	static function easeIn (t:Number, b:Number, c:Number, d:Number):Number {
		return c*(t/=d)*t + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number):Number {
		return -c *(t/=d)*(t-2) + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number):Number {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	}
}

class com.robertpenner.easing.Cubic {
	static function easeIn (t:Number, b:Number, c:Number, d:Number):Number {
		return c*(t/=d)*t*t + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number):Number {
		return c*((t=t/d-1)*t*t + 1) + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number):Number {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	}
}

class com.robertpenner.easing.Quart {
	static function easeIn (t:Number, b:Number, c:Number, d:Number):Number {
		return c*(t/=d)*t*t*t + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number):Number {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number):Number {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	}
}

class com.robertpenner.easing.Quint {
	static function easeIn (t:Number, b:Number, c:Number, d:Number):Number {
		return c*(t/=d)*t*t*t*t + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number):Number {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number):Number {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	}
}

class com.robertpenner.easing.Sine {
	static function easeIn (t:Number, b:Number, c:Number, d:Number):Number {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number):Number {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number):Number {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	}
}

class com.robertpenner.easing.Expo {
	static function easeIn (t:Number, b:Number, c:Number, d:Number):Number {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number):Number {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number):Number {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	}
}

class com.robertpenner.easing.Bounce {
	static function easeOut (t:Number, b:Number, c:Number, d:Number):Number {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}

	}

	static function easeIn (t:Number, b:Number, c:Number, d:Number):Number {
		return c - com.robertpenner.easing.Bounce.easeOut (d-t, 0, c, d) + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number):Number {
		if (t < d/2) return com.robertpenner.easing.Bounce.easeIn (t*2, 0, c, d) * .5 + b;
		else return com.robertpenner.easing.Bounce.easeOut (t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
}

class com.robertpenner.easing.Back {
	static function easeIn (t:Number, b:Number, c:Number, d:Number, s:Number):Number {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number, s:Number):Number {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number, s:Number):Number {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	}
}

class com.robertpenner.easing.Circ {
	static function easeIn (t:Number, b:Number, c:Number, d:Number):Number {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number):Number {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number):Number {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	}
}

class com.robertpenner.easing.Elastic {
	static function easeIn (t:Number, b:Number, c:Number, d:Number, a:Number, p:Number):Number {
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (!a || a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number, a:Number, p:Number):Number {
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (!a || a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return (a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b);
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number, a:Number, p:Number):Number {
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (!a || a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	}
}

class com.robertpenner.easing.Linear {
	static function easeNone (t:Number, b:Number, c:Number, d:Number):Number {
		return c*t/d + b;
	}

	static function easeIn (t:Number, b:Number, c:Number, d:Number):Number {
		return c*t/d + b;
	}

	static function easeOut (t:Number, b:Number, c:Number, d:Number):Number {
		return c*t/d + b;
	}

	static function easeInOut (t:Number, b:Number, c:Number, d:Number):Number {
		return c*t/d + b;
	}
}
