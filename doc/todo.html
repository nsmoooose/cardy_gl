<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
	<title>Cardy GL - TODO</title>
	<link href="todo.css" type="text/css" rel="stylesheet"/>
  </head>
  <body>
	<div class="content">
	  <h1>Cardy GL</h1>
	  <h2>Description</h2>
	  <p>
		This page describes all the things that needs to be done for this project.
	  </p>
	  <h2>Tasks</h2>
	  <table id="todo">
		<thead>
		  <tr>
			<td>Description</td>
			<td>Difficulty</td>
		  </tr>
		</thead>
		<tbody>
		  <tr>
			<td>Pyramid solitaire.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Find more fun solitaires.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Poker</td>
			<td>Hard</td>
		  </tr>
		  <tr>
			<td>
			  Options window with the following content:
			  <ll>
				<li>default deck.</li>
			  </ll>
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Generic messagebox for messages and errors. Also used for yes|no|cancel.</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Functions for generic 3D models with all information about it</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Slidebar control</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Rotation of individual widgets.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Animation of cards between positions</td>
			<td>hard</td>
		  </tr>
		  <tr>
			<td>Statistics about the number of solved solitaires. Storage could be a small sqlite database?</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Fix rendering issue when solitaire is solved. You cannot get back to the main menu and the topmenu control bar is also moving around with the star.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Configurable install directory for linux systems. Currently it is installed in /usr/bin and /usr/share/cardy_gl. Should be customizeable.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  Should have some kind of event model for UI components and let it be configurable.
			  This makes it possible to define a flow between events and new windows and removal of
			  windows. Something like a workflow definition.
			</td>
			<td>hard</td>
		  </tr>
		  <tr>
			<td>
			  Own mouse pointer.
			  Could be implemented using a rendering object applied last to the tree of nodes. We also need to attach a mouse movement handler.
			  This can be used to hide the cursor: glutSetCursor(GLUT_CURSOR_NONE);
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  Have a angle on the camera like in flash cardy. This should be controllable by a
			  slidebar or some buttons in a control somewhere on the screen.
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  <pre>
Create a generic text button control. Some good notes on what is needed:
 * a svg handle, node name, width, height and placement for a image.
 * enumeration on where the text should be placed.
 * text argument.
 * a svg handle, node name for an image that will occupy the entire background.

The above could be accomplished with a control with two child controls. All
three controls should hook the the same click handler.</pre>
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Have some lighting applied.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Have some shading applied.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  Random rotation of each card. +-2 degrees or something like that. Should be remembered
			  for each card between renderings. Sugest an array in the visual pile struct with some
			  predefined rotations when the pile is created.
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  Fix rounded corners on cards. Can this be solved with some kind of beizer curve thingy?
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  <pre>
Start using standard containers. Docs:
A lot of nice glib functionality to use.
 * http://library.gnome.org/devel/glib/stable/index.html
Usefull reading about hashtables
 * http://library.gnome.org/devel/glib/stable/glib-Hash-Tables.html
Expandable arrays.
 * http://library.gnome.org/devel/glib/stable/glib-Arrays.html
Linked lists.
 * http://library.gnome.org/devel/glib/stable/glib-Doubly-Linked-Lists.html
 * http://library.gnome.org/devel/glib/stable/glib-Singly-Linked-Lists.html

Do we wish to hide the fact that we are using this lib? Could create wrappers
around the calls we are using.</pre>
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  <pre>
Transition between different states.

TODO split this up in several smaller tasks!

* Base style that defines a widget without any state set.
* Style for a state. A state can be something like:
-- hover
-- focus
-- selected
-- closing
* Each set property in state style can have three transition expressions set.
-- One for changing to the state.
-- Continous state (an animated button for example)
-- One for leaving the state.
* Each property has a option telling what operation it is in.
-- entering state
-- looping
-- leaving state
* Events when state reaches different operation.
-- Window is removed when fading out effect has been completed. User clicks
   close. We then changes state to "closing". When that state has finished
   its entering state (fade out). We then close the window.
-- Events called after the main loop rendering.

/* *********************************************************************************** */

expression variables common to all widgets (rendering object as well?):
* first_frame
* total_time  Total time this object has been alive.
              This should be a variable in the render_object structure.
              We can then create a special expression that has a pointer to
              this one.

expression functions:
* sin, cos
* ease_xxx_yy

/* *********************************************************************************** */

typedef enum {
		e_entering_state,
		e_continuous_state,
		e_leaving_state
} widget_operation;

/* Enqueu a state change. */
void widget_add_state(render_object *widget, const char *state);

/* Set the leaving state operation for a widget. */
void widget_remove_state(render_object *widget, const char *state);

/* Returns true if the widget or any subwidget has the state active in any transition. */
bool widget_state_active(render_object *widget, const char *state);

typedef struct {
    widget_operation op;
    float length;
    expression *exp;
} transition;

transition *t = widget_transition_create(e_entering_state, 3.0f, expression_parse(""));
widget_style_add_transition(style, "hover", "backcolor_red", t);</pre>
			</td>
			<td>hard</td>
		</tbody>
	  </table>
	</div>
  </body>
</html>
