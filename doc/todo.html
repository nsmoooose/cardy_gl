<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
	<title>Cardy GL - TODO</title>
	<link href="todo.css" type="text/css" rel="stylesheet"/>
  </head>
  <body>
	<div class="content">
	  <h1>Cardy GL</h1>
	  <h2>Description</h2>
	  <p>
		This page describes all the things that needs to be done for this project.
	  </p>
	  <h2>Tasks</h2>
	  <table id="todo">
		<thead>
		  <tr>
			<td>Description</td>
			<td>Difficulty</td>
		  </tr>
		</thead>
		<tbody>
		  <tr>
			<td>Cross compiling for windows on linux box.</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  Server application for multiuser software
			  Tasks:
			  <ul>
				<li>login / logout</li>
				<li>chatting</li>
			  </ul>
			</td>
			<td>hard</td>
		  </tr>
		  <tr>
			<td><del>BUG: Possible to move king to ace cards into outer build up piles in the cross.</del><ins>Done: 2010-03-01</ins></td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Pyramid solitaire.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Non animated version for low cpu usage. Purpose is to reduce battery usage on laptops</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  Find more fun solitaires.
			  <ul>
				<li><del>Heirship</del><ins>Done: 2009-12-19</ins></li>
			  </ul>
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Poker</td>
			<td>hard</td>
		  </tr>
		  <tr>
			<td>
			  Keyboard handling of widgets. Closely related to focus handling. Implementation steps:
			  <ul>
				<li>send keyboard events to all widgets to get us started.</li>
				<li>
				  send keyboard events to control in focus. Then iterate parents
				  until someone handles the event.
				</li>
			  </ul>
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Focus handling of widgets.</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  Animated backgrounds:
			  <ul>
				<li>growing grass.</li>
				<li>fixed svg</li>
			  </ul>
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  Options window with the following content:
			  <ul>
				<li>default deck.</li>
				<li>background</li>
			  </ul>
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Generic messagebox for messages and errors. Also used for yes|no|cancel.</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Functions for generic 3D models with all information about it</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Slidebar control</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>Checkbox control</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>TextBox control</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  Widget rotation:
			  <ul>
				<li><del>Rotation of individual widgets.</del><ins>Done: 2009-11-30</ins></li>
				<li><del>rotation around center of widget as default.</del><ins>Done: 2010-01-31</ins></li>
				<li>rotation center expressions. Should be possible to specify what we rotate around</li>
			  </ul>
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Animation of cards between positions</td>
			<td>hard</td>
		  </tr>
		  <tr>
			<td>
			  Storage backend for config and statistics etc. sqlite should be a good choice.
			  <ul>
				<li>open|close database</li>
			  </ul>
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  Statistics about the number of solved solitaires.
			  Implementation steps:
			  <ul>
				<li>statistics table</li>
				<li>statistics display window</li>
			  </ul>
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td><del>Fix rendering issue when solitaire is solved. You cannot get back to the main menu and the topmenu control bar is also moving around with the star.</del><ins>Fixed: 2009-12-05</ins></td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Configurable install directory for linux systems. Currently it is installed in /usr/bin and /usr/share/cardy_gl. Should be customizeable.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  Should have some kind of event model for UI components and let it be configurable.
			  This makes it possible to define a flow between events and new windows and removal of
			  windows. Something like a workflow definition.
			</td>
			<td>hard</td>
		  </tr>
		  <tr>
			<td>
			  Own mouse pointer.
			  Could be implemented using a rendering object applied last to the tree of nodes. We also need to attach a mouse movement handler.
			  This can be used to hide the cursor: glutSetCursor(GLUT_CURSOR_NONE);
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  <del>Have a angle on the camera like in flash cardy.</del> This should be controllable by a
			  slidebar or some buttons in a control somewhere on the screen.
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  <pre>
Create a generic text button control. Some good notes on what is needed:
 * a svg handle, node name, width, height and placement for a image.
 * enumeration on where the text should be placed.
 * text argument.
 * a svg handle, node name for an image that will occupy the entire background.

The above could be accomplished with a control with two child controls. All
three controls should hook the the same click handler.</pre>
			  Tasks:
			  <ul>
				<li><del>Generate text within a control</del><ins>Done: 2010-01-19</ins></li>
				<li>Scale text according to bitmap sizes and actual size of the control.</li>
				<li>Text centered in the control</li>
				<li>Background color.</li>
				<li>Special effects. Blurred background of the text.</li>
			  </ul>
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  Have some lighting applied. Tasks:
			  <ul>
				<li><del>Setup light source. Should handle when we zoom in and out.</del><ins>Done: 2010-01-05</ins></li>
				<li><del>Calculate normals</del><ins>Done: 2010-01-05</ins></li>
			  </ul>
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>Have some shading applied.</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  Random rotation of each card. +-2 degrees or something like that. Should be remembered
			  for each card between renderings. Sugest an array in the visual pile struct with some
			  predefined rotations when the pile is created.
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  <del>Fix rounded corners on cards.</del><ins>Done: 2010-01-05</ins>
			</td>
			<td>medium</td>
		  </tr>
		  <tr>
			<td>
			  <pre>
Start using standard containers. Docs:
A lot of nice glib functionality to use.
 * http://library.gnome.org/devel/glib/stable/index.html
Usefull reading about hashtables
 * http://library.gnome.org/devel/glib/stable/glib-Hash-Tables.html
Expandable arrays.
 * http://library.gnome.org/devel/glib/stable/glib-Arrays.html
Linked lists.
 * http://library.gnome.org/devel/glib/stable/glib-Doubly-Linked-Lists.html
 * http://library.gnome.org/devel/glib/stable/glib-Singly-Linked-Lists.html

Do we wish to hide the fact that we are using this lib? Could create wrappers
around the calls we are using.</pre>
			  Some steps:
			  <ul>
				<li>style object with all expressions in a hashtable that you can perform lookups in.</li>
			  </ul>
			</td>
			<td>easy</td>
		  </tr>
		  <tr>
			<td>
			  <pre>
Transition between different states.

TODO split this up in several smaller tasks!

* Base style that defines a widget without any state set.
* Style for a state. A state can be something like:
-- hover
-- focus
-- selected
-- closing
* Each set property in state style can have three transition expressions set.
-- One for changing to the state.
-- Continous state (an animated button for example)
-- One for leaving the state.
* Each property has a option telling what operation it is in.
-- entering state
-- looping
-- leaving state
* Events when state reaches different operation.
-- Window is removed when fading out effect has been completed. User clicks
   close. We then changes state to "closing". When that state has finished
   its entering state (fade out). We then close the window.
-- Events called after the main loop rendering.

/* *********************************************************************************** */

typedef enum {
		e_entering_state,
		e_continuous_state,
		e_leaving_state
} widget_operation;

/* Enqueu a state change. */
void widget_add_state(render_object *widget, const char *state);

/* Set the leaving state operation for a widget. */
void widget_remove_state(render_object *widget, const char *state);

/* Returns true if the widget or any subwidget has the state active in any transition. */
bool widget_state_active(render_object *widget, const char *state);

typedef struct {
    widget_operation op;
    float length;
    expression *exp;
} transition;

transition *t = widget_transition_create(e_entering_state, 3.0f, expression_parse(""));
widget_style_add_transition(style, "hover", "backcolor_red", t);</pre>
			  Tasks:
			  <ul>
				<li>Start with a simple hover state?</li>
				<li>todo</li>
			  </ul>
			</td>
			<td>hard</td>
		  </tr>
		  <tr>
			<td>
			  Expression parsing and library. Tasks:
			  <ul>
				<li>parse function expressions.</li>
				<li>expression library. sin, cos, easing functions</li>
			  </ul>
			</td>
			<td>medium</td>
		  </tr>
		</tbody>
	  </table>
	</div>
  </body>
</html>
